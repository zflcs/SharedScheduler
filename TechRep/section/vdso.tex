\section{vDSO 共享机制}

若要用户进程能够实现协程调度运行，最直白的方式是以静态库的形式向用户进程提供依赖，但这种方式存在着弊端：编译时，这些依赖会被编译进 ELF 镜像中，使得内存空间开销增大。这显然是不明智的做法。因此，我们以 vDSO 的方式将 SharedScheduler 共享给内核和用户进程使用。它对外完全透明，仅仅暴露出一组接口供内核和用户进程使用，其内部集成了维护 Executor 数据结构的操作和协程调度算法。然而，在裸机的环境下，实现 vDSO 存在着一些挑战。

\subsection{共享方式}

根据 vDSO 官方手册上的描述，vDSO 是由内核自动链接进用户进程地址空间的共享库。然而，Rust 无法编译出 riscv64gc-unknow-none-elf 架构的共享库文件。但是，其中的关键点是内核先查找符号表，再进行链接。

因此，我们将 SharedScheduler 编译成可执行文件格式，内核将其加载进自己的地址空间中进行维护，并且能够查找符号表信息找到对应的接口信息。在创建进程时，由内核将它映射到用户进程地址空间中，使得用户进程拥有执行相应的接口的权限。这种实现方式的缺陷在于必须将 SharedScheduler 映射到同一段虚拟地址上，牺牲了灵活性。

\subsection{动态链接}

% 在标准库环境下，若在 Rust 中使用共享库，需要先声明外部函数，最后再进行链接。
% 我们仿照这种方式，利用 `get_libfn!`
% (https://github.com/zflcs/rCore-N/blob/main/lib_so/src/lib.rs#L65) 
% 宏来声明外部函数，使得在编写用户程序时能够使用 SharedScheduler 暴露出来的共享库。

% 这个过程宏实际上会针对每个声明的外部函数，创建带有 `VDSO_` 前缀的符号，内核创建用户进程时，
% 解析进程对应的符号表，查找其中带有 `VDSO_` 前缀的符号，再从内核维护的 SharedScheduler 符号表
% 中查找到对应的符号地址并进行链接(https://github.com/zflcs/rCore-N/blob/main/os/src/mm/memory_set.rs#L266)。
% 这种方式不仅仅能够支持更多的共享模块，也能支持标准的共享目标文件。最终，我们通过不同的 feature 向内核和用户暴露出不同的接口，见下表。

\subsection{堆}

% Rust 使用默认的全局分配器（global allocator）在堆上进行分配、释放内存，并且它将协程上下文固定在堆上避免自引用问题。
% 因此，SharedScheduler 与堆之间的联系非常紧密，必须能够动态的完成对内核或用户进程堆的管理。存在两种方式能够达到这种目的。
% 第一种方式是显式的将堆指针当作参数传递给 SharedScheduler 接口；第二种方式是采用某种方式使得全局分配器能够动态的指向内核和进程各自的堆。
% 在这里，我们将内核和用户进程的堆映射到同一个虚拟地址，实现了第二种方式(https://github.com/zflcs/rCore-N/blob/main/lib_so/src/lang_items.rs#L43)。
% 同理，我们以相同的方式解决了动态使用 Executor 的问题。
