\section{异步系统调用}

引入协程机制，是为了利用其异步的特性。若两个任务 A 和 B 被描述成同一线程中的两个协程，且 A 依赖 B，它们不需要进入到内核之中，仅仅在用户态完成。即使 A 的优先级较高，先执行，也可以通过暂停，使得 B 执行相应的任务之后再唤醒 A 继续执行。这个过程体现了协程的好处。

当上述条件不变，任务 A 和 B 仍然是同一线程中的两个协程，两者都需要进入内核且 A 依赖 B。这时存在严格的执行顺序限制，A 必须 B 执行结束之后才能执行。否则 A 一旦先进入内核执行同步系统调用等待 B 完成。在这种场景下，两个任务将会阻塞无法运行。然而，当我们完成对系统调用的改造之后，这种强的执行顺序限制也不复存在，A 先执行系统调用进入内核之后马上返回用户态并暂停，B 开始执行它的任务，结束之后再唤醒 A 继续执行。需要注意，当 A 和 B 被描述成两个线程时，上述场景提到的阻塞问题将不复存在。

我们对系统调用的改造涉及两个方面。一方面，需要将同步和异步系统调用接口进行统一，这需要对用户态系统调用接口进行形式上和功能上的修改；另一方面，内核中的系统调用处理流程需要修改。

\subsection{用户系统调用接口}

对用户态系统调用接口的异步化改造，一方面需要考虑到功能上的差距，另一方面需要考虑到形式上的统一，尽可能缩小和同步系统调用的区别。此外还需要考虑改造过程中的自动化。

% 为了使得系统调用能够支持异步的特征，需要增加辅助的数据结构 AsyncCall(https://github.com/zflcs/rCore-N/blob/main/syscall/src/async_help.rs#L29)，
% 并按照 Rust 语言的要求为其实现 Future trait，完成这个工作之后才能够在调用系统调用时使用 await 关键字。

% 我们力求缩小形式上的差距，考虑到异步系统调用更加复杂，因此，采取的策略是同步系统调用向异步看齐，
% 我们利用了 Rust 语言中的声明宏，定义了 generate_syscall 声明宏(https://github.com/zflcs/rCore-N/blob/main/syscall/src/async_help.rs#L24)，
% 帮助生成同步系统调用和异步系统调用。

最终，同步和异步系统调用在形式上达到高度统一，唯一的区别在于参数的不同。

\subsection{内核系统调用改造}

除了在用户层系统调用接口上的形式一致，我们还追求内核系统调用处理接口上的一致。最终，内核通过判断系统调用参数，选择执行同步或异步处理逻辑。其中异步的处理逻辑是内核采取某种方式使得任务立即返回用户态，而不需要同步的等待相应的处理流程执行完毕再返回用户态。在内核异步的完成相应处理过程之后，再唤醒对应的用户协程。


% 以 read 系统调用(https://github.com/zflcs/rCore-N/blob/main/os/src/syscall/fs.rs#L38)为例，
% 进入内核之后，若执行异步处理，则是将这些同步的处理过程封装成协程，将这个内核协程添加到内核的 Executor 中，再返回到用户态。


% 以异步读管道(https://github.com/zflcs/rCore-N/blob/main/os/src/fs/pipe.rs#L165)为例，异步系统调用返回到用户态之后，
% 内核的处理流程被封装成协程，但并未执行，需要等待内核完成处理之后，才会被唤醒执行。内核执行这个协程，完成相应的处理过程之后，会发起用户态中断，传递需要唤醒的用户协程 ID，由用户态中断处理函数(https://github.com/zflcs/rCore-N/blob/main/user/src/bin/async_demo.rs#L54)唤醒对应的协程。
