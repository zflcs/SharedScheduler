##### 20230407

1. 图A.1和A.2中负载重时，线程的延时和吞吐量很好。这是一个需要仔细分析的情况。目前你的分析并不能说服我。
2. 我倾向于把你目前的附录放到7.2节的对应部分，并且完整在QEMU和FPGA上进行相同参数条件下的实验。有可能吗？

##### 20230322
- 异步管道环设置单核。
- 每个实验都要有参数、代码版本。
- 实验环境交代：既实现了同步的系统调用，也实现了异步系统调用。
- 管道环的各个部分的名称给人误导。

##### 20230312-向勇的意见

1. 3.1.1节第二段中，线程的优先级可以理解为它包括的协程的优先级。这时线程调度需要依据它的优先级进行。
	1. 目前顶多是用运行的协程的优先级表示线程的优先级，但是如果现在正好处于切换的状态时，就不能表示了
	2. 要到后续做调度算法的时候，有了局部队列才能做到这一点
2. 第6节中现在使用的是FCFS调度算法吧？调度框架与调度算法的接口是否已规范定义了？
	调度算法主要取决于 Executor 中成员函数的实现相关，具体的接口名称还需要进一步确定，目前还不是常规的命名

##### 20230305
- 图2 和 图4 的联系
- vDSO 部分几个关键点、口语化问题
- 实验部分直接合并
- 未来展望争取汇报吸引其他同学
- 当前协程的描述与线程没有区别，还需要详细描述

##### 20230304
- 状态模型图新增从线程内部协程指向线程的箭头
- 第四节第二段突出对执行顺序的影响
- 代码改为指向仓库的链接
- vDSO 新增遇到的困难的描述以及解决方案，修改暴露接口
- 新增协程调度部分图片

##### 20230223
讨论：产生异常之后，异常的处理也可以变成异步，之后处理
- 状态模型图需要修改
- 第 4 节第二段的描述换个说法，任务执行的顺序
- 系统调用实质上的统一
- vDSO 和 调度框架进一步完善
- 异步的优劣分析

##### 20230218
调度算法框架、VDSO 的部分还需要详细说明

##### 20230207 ~ 20230208
- 写了主体的部分

###### 20230218-向勇的意见

1. 3.2.2节中协程状态与线程状态的相互影响需要细致的枚举分析。感觉目前的描述有些不清楚。

   1. 协程状态导致线程状态变化：协程让权、协程执行中的异常
   2. 与内部协程无关的外部事件导致线程状态变化：硬件中断响应、
   3. 与内部协程有关的外部事件导致线程状态变化：协程等待的事件出现？

2. 第4节开头第二段的描述，好像不成立。在多核时，B应该可以在另一个核上执行。在单核时，这种情况应该不会出现。它们不应该必须依赖用户态中断。是这样吗？
	1. 多核的时候，B 确实应该在另外的核上执行
	2. 在单核的情况下，正常的用户编程不会故意编写这种出现死锁的情况
	3. 这段的描述的目的是为了体现 引入协程 + 系统调用改造之后，操作系统的异步性更甚

3. 第4节称为“异步系统调用”如何？
	1. 目前的行文是按照我们完成的工作来进行的，概念分析 + 调度的实现、系统调用的改造、目前不成熟的条件下，怎么使用接口
	2. 这里改为异步系统调用更为合适、包括第 5 节的提法


4. 5.1节的提法可以修改一下。共享调度库对外提供的接口就是共享库；基于安全和一致的考虑，共享库由内核维护，并通过vDSO共享给所有用户进程。

5. 表1中的内容需要讨论。yield应该是其中的一个，调度和入队可以不要。
	1. 表中提供的接口是内核、用户编程中需要用到的接口

##### 20230206
![](./Article/assets/flow.excalidraw.png)
- 在线程的维度上，和普通的线程模型一样
- 线程内部协程的状态模型和线程类似
- 线程在阻塞和就绪的状态时，其内部的协程的状态不会发生变化，协程的状态变化只会发生在线程处于运行时（当内核进行了处理，线程从阻塞的状态恢复到就绪的状态时，线程内部的协程等待的事件也已经处理完毕，此时协程理应属于就绪的状态，需要用某种方式将协程状态从阻塞修改为就绪态，用户态中断完成了这个过程，但是用户态中断唤醒协程目前的实现实际上是新开了一个线程执行唤醒的操作，因此还是在线程处于运行的状态时，协程状态发生变化）
![](./Article/assets/relation.excalidraw.png)
- 用黑色的箭头表示内核和所有的用户进程地址空间共享同一份调度器代码

##### 20230204 讨论
- 线程处于就绪状态时，内部的协程的状态不会发生变化
- 线程仍然有阻塞的状态（例如发生了缺页）
- 线程阻塞到线程就绪的状态，其内部的协程的状态的变化需要考虑
- 协程运行到就绪的状态

- CPU 调度泛称、切换地址空间的：进程调度；切换栈：线程调度；最小执行流的调度：协程调度
- 共享的部分的画法需要改

##### 20230203
- 第一幅图
![](./Article/assets/relation.excalidraw.png)
	- 矩形表示数据结构
	- 菱形表示代码
	- 内核和用户进程里的数据结构有哪些
		- 内核和用户进程管理各自的 Executor
		- 内核管理 PCB、TCB ，需要进行一级调度
		- 用户进程通过共享调度器进行二级调度
		- 用户进程和内核进程之间蓝色的部分表示共享的共享调度器的模块，其中包括协程调度的代码（读取进程各自的 Executor 数据结构进行调度，进程各自的位图集成在 Executor 中），还包括共享内存，用一个数组表示所有的进程的最高优先级
	- Executor 指向协程调度代码，这里可能会导致误认为所有的进程的协程一起参与调度，但是实际上只是在某个进程内部进行协程调度，但是，共享调度器在调度时确实会考虑到其他的进程的优先级，从而做出决策
- 第二幅图
![](./Article/assets/flow.excalidraw.png)
	- 椭圆内部黑色箭头表示线程内协程的状态转移，它对应的上下文切换是协程切换
	- 椭圆之间红色箭头表示线程的状态转移，上下文切换是线程切换，需要切换栈
	- 协程的状态模型虽然也是有三种状态，但是不会出现从运行的状态转换为就绪的状态，这与传统的线程状态模型不同，线程的状态模型没有阻塞的状态
	- 不同的状态转移，上下文的切换的范围打算用文字的形式在正文中描述出来，在这个图上不好表现

##### 20230202 讨论图中出现的问题
- 内核下面的文字标注：内核进程
- 内核、用户地址空间共享的内容需要体现，各自的数据结构
- 即使是同一进程内的线程进行切换，仍然需要进到内核，再回到其他的线程，需要切换两次地址空间（后续改动）
- 第一幅图需要画两个进程
- 第二幅图，所有单向箭头都用黑色
- 画内核和两个进程、一个简略
- 先画出单个协程的情况下的状态
- 再表示一个整体的情况下与其他的进程、线程的转移
- 双向箭头表示的上下文切换在状态转移的时候可以体现
对照讨论结果修改图片
- 第一幅图归于共享的部分大致修改完毕
- 第二幅图想到了一种思路，还有些细节需要完善

##### 20230201
- 根据第一幅图，写了引入协程的概念之后，进程、线程这些概念的变化，以及任务调度的方式的变化
- 根据第二幅图，描述了在完全异步的场景下，控制流发生变化的场景，描述了控制流切换的类型，需要保存的上下文的范围等。

##### 20230131
- 修改第一幅图
	- 图中表达了进程主要负责地址空间隔离，线程提供给协程运行的栈，协程则是最小的任务单元
	- 两级调度：进程、线程的调度合并在一起，称之为一级调度（每个进程控制块中的优先级字段记录了当前进程内所有协程的优先级中的最高者，每次进行一级调度时，在最高优先级的进程的所有线程中，选出在就绪线程队列中位置靠前的一个线程执行），实际上是两者有区别，进程调度会导致地址空间切换，而线程调度则是在同一个地址空间中的栈切换；协程调度则是完全在用户态进行，每次选出优先级最高的协程
	- 把线程看作是分配给进程的虚拟的 CPU
![](./Article/assets/relation.excalidraw.png)
- 修改第二幅图
	- 双向箭头表示上下文切换
	- 单向箭头表示控制流切换
	- 有颜色的箭头表示切换的不同情况
	- 线程外的控制流切换由中断/异常或者主动让权引起，可以分为两种情况，一种是切换到同一进程内的线程，这种情况需要保存 `Thread Context`，最明显的特征是切换栈，另一种是切换到其他进程的线程，这需要保存所有的寄存器 `CPU Context`，明显的特征是需要切换地址空间
		- 中断/异常造成的控制流切换可以发生在任何时刻，因此有四个（红绿）箭头
		- 主动让权则只能发生在执行完某个协程之后，因此有两个（红绿）箭头
	- 线程内的控制流切换即协程切换，既不切换地址空间也不切换栈，只会切换协程的上下文
![](./Article/assets/flow.excalidraw.png)

##### 20230130
- 和老师讨论了两幅图的问题
- 用 obsidian 中的 excalidraw 插件画图，自动生成 png 图片，使得文字和图片都在同一个软件中进行修改，保证一致性
- 修改图片

