##### 

1. 摘要和结论：
	1. 强调协程控制块。
	2. 用户态和内核态共享的**协程**的优先级调度算法。
2. 引言部分
	1. 各个工作的特征：长处和短处。
3. 相关工作：
	1. Rust调度模型在第三节中描述。
	2. 用户态中断直接干掉。

##### 20230727-向勇的修改意见

小论文[第一版](https://github.com/zflcs/SharedScheduler/blob/7c96aad699f01f54060f7051dd216e81779fa18e/Shared%20Scheduler%2C%20%20An%20Asynchronous%20Scheduler%20Shared%20by%20Userspace%20and%20Kernel%20Space..md)

1. 摘要和结论：
   1. 目前关于论文贡献的描述不清晰。建议按如下的方式进行描述。异步系统调用可以不强调，后续文章对这个部分还需要进一步的工作，才能展现出异步的好处。正文中也是实现部分才讨论异步系统调用的。
      1. 在内核引入协程控制块，让内核和应用感知协程的状态，并作为内核调度的基本单位。
      2. 定义了协程的优先级属性，设计了一个基于优先级的协程调度算法，内核和应用采用协调一致的调度算法。
      3. 在QEMU和FPGA上对基于优先级的协程调度算法的特征进行了分析。

   2. 摘要和结论中都提到的O(1)调度算法，在正文中基本没有说到。建议只讨论协程优先级的影响，不强调调度算法。
   3. 结论与摘要有相互呼应的关系。目前的呼应还很弱。

2. 引言部分
   1. 操作系统的异步机制中，除epoll和AIO外还需要提到io_uring。在这里还可以提进程和线程的并发特征，再说call back、epoll和io_uring。
   2. 基于用户库和编译器的异步机制描述还需要改进。基于编译的异步机制本质也是用户库；有栈协程就是用户级线程；内核级线程就是把线程库放在内核时，并通过系统调用提供服务接口；goroutine等基于语言支持的有栈协程通过对栈空间的使用做优化。无栈协程（我们说的协程），可以共享栈，基于状态机进行切换，切换开销小；协程的实现也分基于用户库和基于语言支持的，future待基于语言的无栈协程机制对开发者十分友好，可有效减少出错可能。操作系统内核对协程的感知还很少。建议基于这个思路组织参考文献。
   3. 关于“错误处理”这一部分，我没有想明白你的用意。是想说错误处理的延时问题吗？（需要向老师确认）
   4. 最后一段是引出小论文意义的关键。我的理解是，基于语言的协程切换开销小且很好用，但用户程序和操作系统都不感知，于是我们想让内核感知协程，用协程作为调度单位，让内核参与协程调度。
3. 相关工作
   1. Rust异步的描述有些简单和细节了。建议从Rust异步机制的状态机与三状态进程模型的异同来说，它们相似，但内核Rust异步的状态机没有感知。这就是本论文要解决的问题了。
   2. 用户态中断的描述并没有说清楚它与共享调度器的关系。需要从服务论文目标的角度来说用户态中断。建议讨论后约定如何写和写多少与用户态中断相关的内容。
4. 第三节
   1. 第一段的描述有些散，需要简洁地描述论文想解决的挑战是什么。unification, sharing and campatibility这三个特征与论文的主要特征有些偏差。建议围绕摘要中的描述，讨论后确定这里的表达。
   2. 3.1节的图2中，kernel、Proc1和Proc2都应该有与3号箭头，现在Proc2中没有画。目前的文字说明没有说清楚共享调度器的结构。这个图还需要讨论。下面是我的理解。
      * 所有进展有一个通过vDOS共享的SharedScheduler；需要以某种方式表达出“switching coroutine (SC)”与SharedScheduler的关系。我的是理解是，调度器代码并不是独立的协程，在当前协程中执行；SC应该是一个协程，在需要切换线程或进程时执行。
      * 每个协程有一个协程控制块CCB，其中有自己的优先级和当前状态信息；每个进程由若干个协程构成，有一个进程控制块PCB，其中有就绪协程位图和暂停协程等待事件列表；CCB和部分PCB在进程内共享，内核维护PCB和进程中的线程状态；SharedScheduler负责协程状态维护，统一控制进程、线程和协程切换。
      * 这个图里一定要强调“全局就绪位图”，目前还没有。
   3. 3.2节的讨论重点是，每个协程有一个优先级和当前状态，每个进程有一个就绪协程位图和暂停协程等待事件列表，内核有一个全局就绪位图；然后描述协程状态、进程的就绪协程位图、内核的全局就绪位图这三个数据结构的更新过程。建议再画一张图。目前这一节的文字描述有些空泛，要简洁和准确。
   4. 3.3节的“switching coroutine (SC)”需要再讨论。我的理解是，它可以作为一个独立的协程存在，功能是CPU让权和地址空间切换。我还没有想明白，它的优先级如何定义，感觉应该与系统中所有就绪协程的最高优先级一致。
   5. 图3还有可优化的地方。
      1. wake up, intr, schedule这三个箭头还需要讨论。目前这三个箭头与协程没有直接的联系；感觉应该有联系，有可能把waker和中断处理例程视为特殊的线程或协程。
      2. “线程创建”可以视作为进程分配了一个CPU；“线程退出”可以视作就绪协程队列为空时的CPU资源释放。这个想法还需要讨论。
   6. 3.3.1节中，“five-state model for threads”需要有一个出处的文献引用；建议在这里明确地界定线程和协程的各状态表示的含义和区别。
   7. 3.3.2节的内容没有抽象得很清晰。我有如下的一个初步抽象思路。需要大家一起推敲是否可行。
      * 把线程理解为绑定堆栈的协程：状态转换图中不再有线程的出现。
      * 处于运行状态的协程：一定是绑定了栈的；
      * 被抢占协程：处理于就绪状态，并且绑定了栈；
      * 由于执行异常而进入等待的协程：一定是绑定了栈的；
      * 中断处理例程：可视为一个高优先级的协程，平时处理等待状态，有对应中断请求时，会抢占当前运行的协程。
      * 原来的线程可以视为CPU资源的抽象。
5. 第四节：
   1. 建议描述一下CCB的数据结构定义，并说明哪些字段是由编译器自动生成的代码控制，哪些是由内核和应用程序控制。
   2. 4.1节需要“删除已创建协程”和“主动让出CPU”的接口吗？如果我spawn()一个同步函数，会是什么结果？（我的理解是，它好像可以视为一个线程，即不会主动让出CPU的协程）
   3. 4.1节的API需要给出参数信息吗？wake()的描述不够明确。
   4. 4.1节还需要补充一个内容，讨论异步系统调用的返回值传递和协程唤醒过程。
   5. 如果可能，可以把4.1节的示例代码换成socket的send和receive。这样与后续的内容更一致。
   6. 4.2节的插图有些冗余，建议只画与执行异步系统调用的协程的信息，水平方向按时间轴进行组织。
6. 第五节开头讨论的TcpServer的三个组件的名字不好。“Msg Server”容易引起误解，“Msg Sender”说成“Msg Send”会与“Msg Recv”更对应一些。
7. 文字流畅性
   1. 英文的表达不够简洁和流畅，还需要好好润色。（目前可先不处理）
   1. 统一用词，用词要符合本专业通常的含义，尽量少用新词。
      * lightweight coroutine、coroutine

##### 20230407
向勇的意见
1. 摘要：
    1. 让操作系统感知协程，并作为基本调度单位；
    2. 协程优先级
    3. 异步系统调用
2. 2.1节需要先说框架。
3. 异步系统调用应该是重要的内容，建议放到2.1节中；好像vDSO倒是可以放到实现中。
4. 实验：需要统计系统调用的次数，以说明异步系统调用的效果吗？
    1. 优先级：延时和抖动；
    2. 内核协程的实验：在FPGA板子上做用户态和内核态的两个串口进行比较；

线程与协程的关系
1. 用户进程中的线程是用内核级线程实现的；
2. 进程和线程切换：体现为一个协程（这个协程只在内核中存在）；协程切换是一段代码，在当前协程范围内执行；
3. 协程有唯一的ID；
##### 20230407

1. 图A.1和A.2中负载重时，线程的延时和吞吐量很好。这是一个需要仔细分析的情况。目前你的分析并不能说服我。
2. 我倾向于把你目前的附录放到7.2节的对应部分，并且完整在QEMU和FPGA上进行相同参数条件下的实验。有可能吗？

##### 20230322
- 异步管道环设置单核。
- 每个实验都要有参数、代码版本。
- 实验环境交代：既实现了同步的系统调用，也实现了异步系统调用。
- 管道环的各个部分的名称给人误导。

##### 20230312-向勇的意见

1. 3.1.1节第二段中，线程的优先级可以理解为它包括的协程的优先级。这时线程调度需要依据它的优先级进行。
	1. 目前顶多是用运行的协程的优先级表示线程的优先级，但是如果现在正好处于切换的状态时，就不能表示了
	2. 要到后续做调度算法的时候，有了局部队列才能做到这一点
2. 第6节中现在使用的是FCFS调度算法吧？调度框架与调度算法的接口是否已规范定义了？
	调度算法主要取决于 Executor 中成员函数的实现相关，具体的接口名称还需要进一步确定，目前还不是常规的命名

##### 20230305
- 图2 和 图4 的联系
- vDSO 部分几个关键点、口语化问题
- 实验部分直接合并
- 未来展望争取汇报吸引其他同学
- 当前协程的描述与线程没有区别，还需要详细描述

##### 20230304
- 状态模型图新增从线程内部协程指向线程的箭头
- 第四节第二段突出对执行顺序的影响
- 代码改为指向仓库的链接
- vDSO 新增遇到的困难的描述以及解决方案，修改暴露接口
- 新增协程调度部分图片

##### 20230223
讨论：产生异常之后，异常的处理也可以变成异步，之后处理
- 状态模型图需要修改
- 第 4 节第二段的描述换个说法，任务执行的顺序
- 系统调用实质上的统一
- vDSO 和 调度框架进一步完善
- 异步的优劣分析

##### 20230218
调度算法框架、VDSO 的部分还需要详细说明

##### 20230207 ~ 20230208
- 写了主体的部分

###### 20230218-向勇的意见

1. 3.2.2节中协程状态与线程状态的相互影响需要细致的枚举分析。感觉目前的描述有些不清楚。

   1. 协程状态导致线程状态变化：协程让权、协程执行中的异常
   2. 与内部协程无关的外部事件导致线程状态变化：硬件中断响应、
   3. 与内部协程有关的外部事件导致线程状态变化：协程等待的事件出现？

2. 第4节开头第二段的描述，好像不成立。在多核时，B应该可以在另一个核上执行。在单核时，这种情况应该不会出现。它们不应该必须依赖用户态中断。是这样吗？
	1. 多核的时候，B 确实应该在另外的核上执行
	2. 在单核的情况下，正常的用户编程不会故意编写这种出现死锁的情况
	3. 这段的描述的目的是为了体现 引入协程 + 系统调用改造之后，操作系统的异步性更甚

3. 第4节称为“异步系统调用”如何？
	1. 目前的行文是按照我们完成的工作来进行的，概念分析 + 调度的实现、系统调用的改造、目前不成熟的条件下，怎么使用接口
	2. 这里改为异步系统调用更为合适、包括第 5 节的提法


4. 5.1节的提法可以修改一下。共享调度库对外提供的接口就是共享库；基于安全和一致的考虑，共享库由内核维护，并通过vDSO共享给所有用户进程。

5. 表1中的内容需要讨论。yield应该是其中的一个，调度和入队可以不要。
	1. 表中提供的接口是内核、用户编程中需要用到的接口

##### 20230206
![](./Article/assets/flow.excalidraw.png)
- 在线程的维度上，和普通的线程模型一样
- 线程内部协程的状态模型和线程类似
- 线程在阻塞和就绪的状态时，其内部的协程的状态不会发生变化，协程的状态变化只会发生在线程处于运行时（当内核进行了处理，线程从阻塞的状态恢复到就绪的状态时，线程内部的协程等待的事件也已经处理完毕，此时协程理应属于就绪的状态，需要用某种方式将协程状态从阻塞修改为就绪态，用户态中断完成了这个过程，但是用户态中断唤醒协程目前的实现实际上是新开了一个线程执行唤醒的操作，因此还是在线程处于运行的状态时，协程状态发生变化）
![](./Article/assets/relation.excalidraw.png)
- 用黑色的箭头表示内核和所有的用户进程地址空间共享同一份调度器代码

##### 20230204 讨论
- 线程处于就绪状态时，内部的协程的状态不会发生变化
- 线程仍然有阻塞的状态（例如发生了缺页）
- 线程阻塞到线程就绪的状态，其内部的协程的状态的变化需要考虑
- 协程运行到就绪的状态

- CPU 调度泛称、切换地址空间的：进程调度；切换栈：线程调度；最小执行流的调度：协程调度
- 共享的部分的画法需要改

##### 20230203
- 第一幅图
![](./Article/assets/relation.excalidraw.png)
	- 矩形表示数据结构
	- 菱形表示代码
	- 内核和用户进程里的数据结构有哪些
		- 内核和用户进程管理各自的 Executor
		- 内核管理 PCB、TCB ，需要进行一级调度
		- 用户进程通过共享调度器进行二级调度
		- 用户进程和内核进程之间蓝色的部分表示共享的共享调度器的模块，其中包括协程调度的代码（读取进程各自的 Executor 数据结构进行调度，进程各自的位图集成在 Executor 中），还包括共享内存，用一个数组表示所有的进程的最高优先级
	- Executor 指向协程调度代码，这里可能会导致误认为所有的进程的协程一起参与调度，但是实际上只是在某个进程内部进行协程调度，但是，共享调度器在调度时确实会考虑到其他的进程的优先级，从而做出决策
- 第二幅图
![](./Article/assets/flow.excalidraw.png)
	- 椭圆内部黑色箭头表示线程内协程的状态转移，它对应的上下文切换是协程切换
	- 椭圆之间红色箭头表示线程的状态转移，上下文切换是线程切换，需要切换栈
	- 协程的状态模型虽然也是有三种状态，但是不会出现从运行的状态转换为就绪的状态，这与传统的线程状态模型不同，线程的状态模型没有阻塞的状态
	- 不同的状态转移，上下文的切换的范围打算用文字的形式在正文中描述出来，在这个图上不好表现

##### 20230202 讨论图中出现的问题
- 内核下面的文字标注：内核进程
- 内核、用户地址空间共享的内容需要体现，各自的数据结构
- 即使是同一进程内的线程进行切换，仍然需要进到内核，再回到其他的线程，需要切换两次地址空间（后续改动）
- 第一幅图需要画两个进程
- 第二幅图，所有单向箭头都用黑色
- 画内核和两个进程、一个简略
- 先画出单个协程的情况下的状态
- 再表示一个整体的情况下与其他的进程、线程的转移
- 双向箭头表示的上下文切换在状态转移的时候可以体现
对照讨论结果修改图片
- 第一幅图归于共享的部分大致修改完毕
- 第二幅图想到了一种思路，还有些细节需要完善

##### 20230201
- 根据第一幅图，写了引入协程的概念之后，进程、线程这些概念的变化，以及任务调度的方式的变化
- 根据第二幅图，描述了在完全异步的场景下，控制流发生变化的场景，描述了控制流切换的类型，需要保存的上下文的范围等。

##### 20230131
- 修改第一幅图
	- 图中表达了进程主要负责地址空间隔离，线程提供给协程运行的栈，协程则是最小的任务单元
	- 两级调度：进程、线程的调度合并在一起，称之为一级调度（每个进程控制块中的优先级字段记录了当前进程内所有协程的优先级中的最高者，每次进行一级调度时，在最高优先级的进程的所有线程中，选出在就绪线程队列中位置靠前的一个线程执行），实际上是两者有区别，进程调度会导致地址空间切换，而线程调度则是在同一个地址空间中的栈切换；协程调度则是完全在用户态进行，每次选出优先级最高的协程
	- 把线程看作是分配给进程的虚拟的 CPU
![](./Article/assets/relation.excalidraw.png)
- 修改第二幅图
	- 双向箭头表示上下文切换
	- 单向箭头表示控制流切换
	- 有颜色的箭头表示切换的不同情况
	- 线程外的控制流切换由中断/异常或者主动让权引起，可以分为两种情况，一种是切换到同一进程内的线程，这种情况需要保存 `Thread Context`，最明显的特征是切换栈，另一种是切换到其他进程的线程，这需要保存所有的寄存器 `CPU Context`，明显的特征是需要切换地址空间
		- 中断/异常造成的控制流切换可以发生在任何时刻，因此有四个（红绿）箭头
		- 主动让权则只能发生在执行完某个协程之后，因此有两个（红绿）箭头
	- 线程内的控制流切换即协程切换，既不切换地址空间也不切换栈，只会切换协程的上下文
![](./Article/assets/flow.excalidraw.png)

##### 20230130
- 和老师讨论了两幅图的问题
- 用 obsidian 中的 excalidraw 插件画图，自动生成 png 图片，使得文字和图片都在同一个软件中进行修改，保证一致性
- 修改图片

