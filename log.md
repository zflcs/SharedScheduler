
##### 20230203
- 第一幅图
![](./Article/assets/relation.excalidraw.png)
	- 矩形表示数据结构
	- 菱形表示代码
	- 内核和用户进程里的数据结构有哪些
		- 内核和用户进程管理各自的 Executor
		- 内核管理 PCB、TCB ，需要进行一级调度
		- 用户进程通过共享调度器进行二级调度
		- 用户进程和内核进程之间蓝色的部分表示共享的共享调度器的模块，其中包括协程调度的代码（读取进程各自的 Executor 数据结构进行调度，进程各自的位图集成在 Executor 中），还包括共享内存，用一个数组表示所有的进程的最高优先级
- 第二幅图
![](./Article/assets/flow.excalidraw.png)
	- 椭圆内部黑色箭头表示线程内协程的状态转移，它对应的上下文切换是协程切换
	- 椭圆之间红色箭头表示线程的状态转移，上下文切换是线程切换，需要切换栈
	- 协程的状态模型虽然也是有三种状态，但是不会出现从运行的状态转换为就绪的状态，这与传统的线程状态模型不同，线程的状态模型没有阻塞的状态
	- 不同的状态转移，上下文的切换的范围打算用文字的形式在正文中描述出来，在这个图上不好表现

##### 20230202 讨论图中出现的问题
- 内核下面的文字标注：内核进程
- 内核、用户地址空间共享的内容需要体现，各自的数据结构
- 即使是同一进程内的线程进行切换，仍然需要进到内核，再回到其他的线程，需要切换两次地址空间（后续改动）
- 第一幅图需要画两个进程
- 第二幅图，所有单向箭头都用黑色
- 画内核和两个进程、一个简略
- 先画出单个协程的情况下的状态
- 再表示一个整体的情况下与其他的进程、线程的转移
- 双向箭头表示的上下文切换在状态转移的时候可以体现
对照讨论结果修改图片
- 第一幅图归于共享的部分大致修改完毕
- 第二幅图想到了一种思路，还有些细节需要完善

##### 20230201
- 根据第一幅图，写了引入协程的概念之后，进程、线程这些概念的变化，以及任务调度的方式的变化
- 根据第二幅图，描述了在完全异步的场景下，控制流发生变化的场景，描述了控制流切换的类型，需要保存的上下文的范围等。

##### 20230131
- 修改第一幅图
	- 图中表达了进程主要负责地址空间隔离，线程提供给协程运行的栈，协程则是最小的任务单元
	- 两级调度：进程、线程的调度合并在一起，称之为一级调度（每个进程控制块中的优先级字段记录了当前进程内所有协程的优先级中的最高者，每次进行一级调度时，在最高优先级的进程的所有线程中，选出在就绪线程队列中位置靠前的一个线程执行），实际上是两者有区别，进程调度会导致地址空间切换，而线程调度则是在同一个地址空间中的栈切换；协程调度则是完全在用户态进行，每次选出优先级最高的协程
	- 把线程看作是分配给进程的虚拟的 CPU
![](./Article/assets/relation.excalidraw.png)
- 修改第二幅图
	- 双向箭头表示上下文切换
	- 单向箭头表示控制流切换
	- 有颜色的箭头表示切换的不同情况
	- 线程外的控制流切换由中断/异常或者主动让权引起，可以分为两种情况，一种是切换到同一进程内的线程，这种情况需要保存 `Thread Context`，最明显的特征是切换栈，另一种是切换到其他进程的线程，这需要保存所有的寄存器 `CPU Context`，明显的特征是需要切换地址空间
		- 中断/异常造成的控制流切换可以发生在任何时刻，因此有四个（红绿）箭头
		- 主动让权则只能发生在执行完某个协程之后，因此有两个（红绿）箭头
	- 线程内的控制流切换即协程切换，既不切换地址空间也不切换栈，只会切换协程的上下文
![](./Article/assets/flow.excalidraw.png)

##### 20230130
- 和老师讨论了两幅图的问题
- 用 obsidian 中的 excalidraw 插件画图，自动生成 png 图片，使得文字和图片都在同一个软件中进行修改，保证一致性
- 修改图片